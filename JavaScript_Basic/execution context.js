//실행 컨텍스트
//-------------------(1)
var a = 1;

function outer() { // var a 값은 function outer 값에 들어 올 수 있는건가?
    function inner() {
        console.log(a);
        var a = 3;

    }
    inner(); //-------------------(2)
    console.log(a);
}
outer(); //-------------------(3)
console.log(a);

//전역 컨텍스트 실행 순서
// 3 ->

/* 콜 스택에 실행 컨텍스트가 어떤 순서로 쌓이고, 어떤 순서로 코드 실행에 관여 하는지만 확인 할 수 있으면 됩니다.
*
* 콜 스택에는 전역 컨텍스트 외에 다른 덩어리가 없으므로 전역 컨텍스트와 코드들을 순차로 진행하다가
* (3)에서 outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담습니다.
* 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태가 됐으므로 전역 컨텍스트와 관련된 코드의 실행을 일시중단하고 대신 outer 실행 컨텍스트와 관련된 코드,
* 즉 outer 함수 내부의 코드들을 순차적으로 실행합니다.
* 다시 (2)에서 inner 함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 outer 컨텍스트와 관련된 코드의 실행을 중단하고 inner 함수 내부의 코드를 순서대로
* 진행할 것입니다.
*
* inner 함수 내부에서 a 변수에 값이 3을 할당하고 나면 inner 함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거됩니다.
* 그러면 아래에 있던 outer 컨텍스트가 콜 스택의 맨 위에 존재하게 되므로 중단 했던 (2)의 다음 줄 부터 이어 실행 합니다.
* a 변수의 값을 출력하고 나면 outer 함수의 실행이 종료되어 outer 실행 컨텍스트가 콜 스택에서 제거되고, 콜 스택에서는 전역 컨텍스트만 남아 있게 됩니다.
* 그런 다음, 실행을 중단했던 (3)의 다음 줄부터 이어서 실행합니다. a 변수의 값을 출력하고 나면 전역 컨텍스타도 제거되고,
* 콜 스택에는 아무것도 남지 않은 상태로 종료됩니다.
*
* 자바스크립트 엔진은 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장합니다.
*
*  VariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영 되지 않음
*
* */


